#include <check.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#include "s21_matrix.h"

// Тесты на создание матрицы
#test create_1
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);
for (int i = 0; i < rows; i++) {
  for (int j = 0; j < cols; j++) {
    m.matrix[i][j] = 0;
    ck_assert_ldouble_eq_tol(0, m.matrix[i][j], 1e-07);
  }
}
ck_assert_int_eq(m.rows, rows);
ck_assert_int_eq(m.columns, cols);
s21_remove_matrix(&m);

#test create_2
int rows = 0;
int cols = 10;
matrix_t m = {0};
ck_assert_int_eq(s21_create_matrix(rows, cols, &m), INCORRECT_MATRIX);

#test create_3
int rows = 10;
int cols = 0;

matrix_t m = {0};
ck_assert_int_eq(s21_create_matrix(rows, cols, &m), INCORRECT_MATRIX);

#test create_4
int rows = 1;
int cols = 1;

matrix_t m = {0};
ck_assert_int_eq(s21_create_matrix(rows, cols, &m), OK);

//Тесты на Сравнение матриц
#test eq_matrix
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
s21_create_matrix(rows, cols, &mtx);
for (int i = 0; i < rows; i++) {
  for (int j = 0; j < cols; j++) {
    double rand_val = get_rand(DBL_MIN, DBL_MAX);
    m.matrix[i][j] = rand_val;
    mtx.matrix[i][j] = rand_val;
  }
}
ck_assert_int_eq(s21_eq_matrix(&m, &mtx), SUCCESS);
s21_remove_matrix(&m);
s21_remove_matrix(&mtx);

#test not_eq
matrix_t m = {0};
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
int rows1 = rand() % 100 + 1;
int cols1 = rand() % 100 + 1;
s21_create_matrix(rows1, cols1, &mtx);

for (int i = 0; i < rows; i++) {
  for (int j = 0; j < cols; j++) {
    m.matrix[i][j] = get_rand(DBL_MIN, DBL_MAX) + 1;
  }
}
for (int i = 0; i < rows1; i++) {
  for (int j = 0; j < cols1; j++) {
    mtx.matrix[i][j] = get_rand(DBL_MIN, DBL_MAX);
  }
}
ck_assert_int_eq(s21_eq_matrix(&m, &mtx), 0);
s21_remove_matrix(&m);
s21_remove_matrix(&mtx);

#test not_eq1
matrix_t m = {0};
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
rows = -rows;
cols = -cols;
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
int rows1 = rand() % 100 + 1;
int cols1 = rand() % 100 + 1;
s21_create_matrix(rows1, cols1, &mtx);
ck_assert_int_eq(s21_eq_matrix(&m, &mtx), FAILURE);
s21_remove_matrix(&m);
s21_remove_matrix(&mtx);

#test zero_matrix
matrix_t A = {0};
matrix_t B = {0};
int result = s21_eq_matrix(&A, &B);
ck_assert_int_eq(0, result);

#test zero_matrix_1
matrix_t A = {0};
matrix_t B = {0};
s21_create_matrix(0, 0, &A);
s21_create_matrix(0, 0, &B);
int result = s21_eq_matrix(&A, &B);
ck_assert_int_eq(0, result);
s21_remove_matrix(&A);
s21_remove_matrix(&B);

#test casual_matrix_1
matrix_t A = {0};
matrix_t B = {0};
s21_create_matrix(1, 1, &A);
s21_create_matrix(1, 1, &B);
A.matrix[0][0] = 1;
B.matrix[0][0] = 1;
int result = s21_eq_matrix(&A, &B);
ck_assert_int_eq(1, result);
s21_remove_matrix(&A);
s21_remove_matrix(&B);

#test casual_matrix_2
matrix_t A = {0};
matrix_t B = {0};
s21_create_matrix(1, 1, &A);
s21_create_matrix(1, 1, &B);
A.matrix[0][0] = 1;
B.matrix[0][0] = 2;
int result = s21_eq_matrix(&A, &B);
ck_assert_int_eq(0, result);
s21_remove_matrix(&A);
s21_remove_matrix(&B);

#test casual_matrix_3
matrix_t A = {0};
matrix_t B = {0};
s21_create_matrix(2, 2, &A);
s21_create_matrix(2, 2, &B);
A.matrix[0][0] = 1;
A.matrix[0][1] = 2;
A.matrix[1][0] = 3;
A.matrix[1][1] = 4;
B.matrix[0][0] = 1;
B.matrix[0][1] = 2;
B.matrix[1][0] = 3;
B.matrix[1][1] = 4;
int result = s21_eq_matrix(&A, &B);
ck_assert_int_eq(1, result);
s21_remove_matrix(&A);
s21_remove_matrix(&B);

#test casual_matrix_4
matrix_t A = {0};
matrix_t B = {0};
s21_create_matrix(2, 2, &A);
s21_create_matrix(2, 2, &B);
A.matrix[0][0] = 1;
A.matrix[0][1] = 2;
A.matrix[1][0] = 3;
A.matrix[1][1] = 4;
B.matrix[0][0] = 1;
B.matrix[0][1] = 2;
B.matrix[1][0] = 3;
B.matrix[1][1] = 4;
int result = s21_eq_matrix(&A, &B);
ck_assert_int_eq(1, result);
s21_remove_matrix(&A);
s21_remove_matrix(&B);

#test casual_matrix_5
matrix_t A = {0};
matrix_t B = {0};
s21_create_matrix(2, 2, &A);
s21_create_matrix(2, 2, &B);
A.matrix[0][0] = 1.01;
A.matrix[0][1] = 2;
A.matrix[1][0] = 3.05;
A.matrix[1][1] = 4;
B.matrix[0][0] = 1.01;
B.matrix[0][1] = 2;
B.matrix[1][0] = 3.05;
B.matrix[1][1] = 4;
int result = s21_eq_matrix(&A, &B);
ck_assert_int_eq(1, result);
s21_remove_matrix(&A);
s21_remove_matrix(&B);

#test casual_matrix_6
matrix_t A = {0};
matrix_t B = {0};
s21_create_matrix(2, 2, &A);
s21_create_matrix(2, 2, &B);
A.matrix[0][0] = 1.01;
A.matrix[0][1] = -2;
A.matrix[1][0] = 3.05;
A.matrix[1][1] = -4;
B.matrix[0][0] = 1.01;
B.matrix[0][1] = -2;
B.matrix[1][0] = 3.05;
B.matrix[1][1] = -4;
int result = s21_eq_matrix(&A, &B);
ck_assert_int_eq(1, result);
s21_remove_matrix(&A);
s21_remove_matrix(&B);

#test casual_matrix_7
matrix_t A = {0};
matrix_t B = {0};
s21_create_matrix(2, 2, &A);
s21_create_matrix(2, 2, &B);
A.matrix[0][0] = 1.000000100234;
A.matrix[0][1] = 2;
A.matrix[1][0] = 3.05;
A.matrix[1][1] = 4;
B.matrix[0][0] = 1;
B.matrix[0][1] = 2;
B.matrix[1][0] = 3.05;
B.matrix[1][1] = 4;
int result = s21_eq_matrix(&A, &B);
ck_assert_int_eq(1, result);
s21_remove_matrix(&A);
s21_remove_matrix(&B);

#test casual_matrix_8
matrix_t A = {0};
matrix_t B = {0};
s21_create_matrix(2, 2, &A);
s21_create_matrix(2, 2, &B);
A.matrix[0][0] = 1.0001;
A.matrix[0][1] = 2;
A.matrix[1][0] = 3.05;
A.matrix[1][1] = 4;
B.matrix[0][0] = 1;
B.matrix[0][1] = 2;
B.matrix[1][0] = 3.05;
B.matrix[1][1] = 4;
int result = s21_eq_matrix(&A, &B);
ck_assert_int_eq(0, result);
s21_remove_matrix(&A);
s21_remove_matrix(&B);

// Тесты на сложение матриц
#test sum_matrix
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
s21_create_matrix(rows, cols, &mtx);
matrix_t check = {0};
s21_create_matrix(rows, cols, &check);

for (int i = 0; i < rows; i++) {
  for (int j = 0; j < cols; j++) {
    m.matrix[i][j] = get_rand(DBL_MIN, DBL_MAX);
    mtx.matrix[i][j] = get_rand(DBL_MIN, DBL_MAX);
    check.matrix[i][j] = m.matrix[i][j] + mtx.matrix[i][j];
  }
}
matrix_t res = {0};

ck_assert_int_eq(s21_sum_matrix(&m, &mtx, &res), OK);
ck_assert_int_eq(s21_eq_matrix(&check, &res), SUCCESS);
s21_remove_matrix(&m);
s21_remove_matrix(&mtx);
s21_remove_matrix(&res);
s21_remove_matrix(&check);

#test sum_matrix1
matrix_t m = {0};
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
int rows1 = rand() % 100 + 1;
int cols1 = rand() % 100 + 1;
s21_create_matrix(rows1, cols1, &mtx);

generate_matrix(&m);
generate_matrix(&mtx);

matrix_t res = {0};
ck_assert_int_eq(s21_sum_matrix(&m, &mtx, &res), CALC_ERROR);
s21_remove_matrix(&m);
s21_remove_matrix(&mtx);
s21_remove_matrix(&res);

#test sum_matrix2
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
rows = -rows;
cols = -cols;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
s21_create_matrix(rows, cols, &mtx);
matrix_t check = {0};
s21_create_matrix(rows, cols, &check);

matrix_t res = {0};

ck_assert_int_eq(s21_sum_matrix(&m, &mtx, &res), INCORRECT_MATRIX);
s21_remove_matrix(&m);
s21_remove_matrix(&mtx);
s21_remove_matrix(&res);
s21_remove_matrix(&check);

// Тесты на вычетание матриц
#test sub_matrix
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
s21_create_matrix(rows, cols, &mtx);
matrix_t check = {0};
s21_create_matrix(rows, cols, &check);

for (int i = 0; i < rows; i++) {
  for (int j = 0; j < cols; j++) {
    m.matrix[i][j] = get_rand(DBL_MIN, DBL_MAX);
    mtx.matrix[i][j] = get_rand(DBL_MIN, DBL_MAX);
    check.matrix[i][j] = m.matrix[i][j] - mtx.matrix[i][j];
  }
}
matrix_t res = {0};
ck_assert_int_eq(s21_sub_matrix(&m, &mtx, &res), OK);
ck_assert_int_eq(s21_eq_matrix(&check, &res), SUCCESS);

s21_remove_matrix(&m);
s21_remove_matrix(&mtx);
s21_remove_matrix(&res);
s21_remove_matrix(&check);

#test sub_matrix1
matrix_t m = {0};
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
int rows1 = rand() % 100 + 1;
int cols1 = rand() % 100 + 1;
s21_create_matrix(rows1, cols1, &mtx);

generate_matrix(&m);
generate_matrix(&mtx);

matrix_t res = {0};
ck_assert_int_eq(s21_sub_matrix(&m, &mtx, &res), CALC_ERROR);
s21_remove_matrix(&m);
s21_remove_matrix(&mtx);
s21_remove_matrix(&res);

#test sub_matrix2
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
rows = -rows;
cols = -cols;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
s21_create_matrix(rows, cols, &mtx);
matrix_t check = {0};
s21_create_matrix(rows, cols, &check);

matrix_t res = {0};
ck_assert_int_eq(s21_sub_matrix(&m, &mtx, &res), INCORRECT_MATRIX);

s21_remove_matrix(&m);
s21_remove_matrix(&mtx);
s21_remove_matrix(&res);
s21_remove_matrix(&check);

// Тесты умножение матрицы на число
#test mult_number_matrix
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);
matrix_t check = {0};
s21_create_matrix(rows, cols, &check);
double mult_number = get_rand(-10e5, 10e5);
for (int i = 0; i < rows; i++) {
  for (int j = 0; j < cols; j++) {
    m.matrix[i][j] = get_rand(DBL_MIN, DBL_MAX);
    check.matrix[i][j] = m.matrix[i][j] * mult_number;
  }
}
matrix_t res = {0};
ck_assert_int_eq(s21_mult_number(&m, mult_number, &res), OK);
ck_assert_int_eq(s21_eq_matrix(&check, &res), SUCCESS);
s21_remove_matrix(&m);
s21_remove_matrix(&res);
s21_remove_matrix(&check);

#test mult_number_matrix2
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
rows = -rows;
cols = -cols;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);
matrix_t check = {0};
s21_create_matrix(rows, cols, &check);
double mult_number = get_rand(-10e5, 10e5);

matrix_t res = {0};
ck_assert_int_eq(s21_mult_number(&m, mult_number, &res), INCORRECT_MATRIX);

s21_remove_matrix(&m);
s21_remove_matrix(&res);
s21_remove_matrix(&check);

// Тесты умножение матриц
#test mult_matrix
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
s21_create_matrix(cols, rows, &mtx);

for (int i = 0; i < rows; i++)
  for (int j = 0; j < cols; j++) m.matrix[i][j] = get_rand(-10e10, 10e10);

for (int i = 0; i < cols; i++)
  for (int j = 0; j < rows; j++) mtx.matrix[i][j] = get_rand(-10e10, 10e10);

matrix_t check = {0};
s21_create_matrix(m.rows, mtx.columns, &check);

for (int i = 0; i < m.rows; i++) {
  for (int j = 0; j < mtx.columns; j++) {
    check.matrix[i][j] = 0;
    for (int k = 0; k < m.columns; k++)
      check.matrix[i][j] += m.matrix[i][k] * mtx.matrix[k][j];
  }
}

matrix_t res = {0};
ck_assert_int_eq(s21_mult_matrix(&m, &mtx, &res), OK);
ck_assert_int_eq(s21_eq_matrix(&check, &res), SUCCESS);

s21_remove_matrix(&m);
s21_remove_matrix(&mtx);
s21_remove_matrix(&res);
s21_remove_matrix(&check);

#test simple_mult
int rows = 2;
int cols = 3;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
s21_create_matrix(cols, rows, &mtx);

for (int i = 0, c = 1; i < rows; i++)
  for (int j = 0; j < cols; j++) m.matrix[i][j] = c++;

for (int i = 0, c = 7; i < cols; i++)
  for (int j = 0; j < rows; j++) mtx.matrix[i][j] = c++;

matrix_t check = {0};
s21_create_matrix(m.rows, mtx.columns, &check);
check.matrix[0][0] = 58;
check.matrix[0][1] = 64;
check.matrix[1][0] = 139;
check.matrix[1][1] = 154;

matrix_t res = {0};
ck_assert_int_eq(s21_mult_matrix(&m, &mtx, &res), OK);
ck_assert_int_eq(s21_eq_matrix(&check, &res), SUCCESS);

s21_remove_matrix(&m);
s21_remove_matrix(&mtx);
s21_remove_matrix(&res);
s21_remove_matrix(&check);

#test mult_matrix2
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
rows = -rows;
cols = -cols;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
s21_create_matrix(cols, rows, &mtx);

matrix_t check = {0};
s21_create_matrix(m.rows, mtx.columns, &check);

matrix_t res = {0};
ck_assert_int_eq(s21_mult_matrix(&m, &mtx, &res), INCORRECT_MATRIX);

s21_remove_matrix(&m);
s21_remove_matrix(&mtx);
s21_remove_matrix(&res);
s21_remove_matrix(&check);

#test mult_matrix3
matrix_t m = {0};
int rows = 2;
int cols = 3;
s21_create_matrix(rows, cols, &m);
matrix_t mtx = {0};
int rows1 = 4;
int cols1 = 5;
s21_create_matrix(rows1, cols1, &mtx);

matrix_t check = {0};
s21_create_matrix(m.rows, mtx.columns, &check);

matrix_t res = {0};
ck_assert_int_eq(s21_mult_matrix(&m, &mtx, &res), CALC_ERROR);

s21_remove_matrix(&m);
s21_remove_matrix(&mtx);
s21_remove_matrix(&res);
s21_remove_matrix(&check);

#test mult_matrix4
matrix_t A, B, R, Z;
s21_create_matrix(1, 2, &A);
s21_create_matrix(2, 2, &B);
s21_create_matrix(1, 2, &R);

A.matrix[0][0] = 90.56711652816495;
A.matrix[0][1] = 7.664389277391322;

B.matrix[0][0] = 48.261763544430636;
B.matrix[0][1] = -73.6766162164931;
B.matrix[1][0] = 81.33785819592393;
B.matrix[1][1] = -37.97769763356647;

R.matrix[0][0] = 4994.333770986007;
R.matrix[0][1] = -6963.754544802735;

int res = s21_mult_matrix(&A, &B, &Z);
ck_assert_int_eq(res, 0);
int qqq = s21_eq_matrix(&R, &Z);
ck_assert_int_eq(qqq, 1);
s21_remove_matrix(&A);
s21_remove_matrix(&B);
s21_remove_matrix(&R);
s21_remove_matrix(&Z);

// Тесты на транспонирование матрицы
#test transpose_matrix
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);

matrix_t check = {0};
s21_create_matrix(cols, rows, &check);

for (int i = 0; i < rows; i++) {
  for (int j = 0; j < cols; j++) {
    double rand_val = get_rand(-10e10, 10e10);
    m.matrix[i][j] = rand_val;
    check.matrix[j][i] = rand_val;
  }
}

matrix_t res = {0};
ck_assert_int_eq(s21_transpose(&m, &res), OK);
ck_assert_int_eq(s21_eq_matrix(&check, &res), SUCCESS);

s21_remove_matrix(&m);
s21_remove_matrix(&res);
s21_remove_matrix(&check);

#test transpose_matrix2
int rows = rand() % 100 + 1;
int cols = rand() % 100 + 1;
rows = -rows;
cols = -cols;
matrix_t m = {0};
s21_create_matrix(rows, cols, &m);
matrix_t check = {0};
s21_create_matrix(cols, rows, &check);

matrix_t res = {0};
ck_assert_int_eq(s21_transpose(&m, &res), INCORRECT_MATRIX);

s21_remove_matrix(&m);
s21_remove_matrix(&res);
s21_remove_matrix(&check);

#test transpose_matrix3
matrix_t A, R, REZ;
s21_create_matrix(2, 1, &A);
s21_create_matrix(1, 2, &REZ);
A.matrix[0][0] = 39.445589;
A.matrix[1][0] = 45.244559;
REZ.matrix[0][0] = 39.445589;
REZ.matrix[0][1] = 45.244559;
int ret = s21_transpose(&A, &R);
ck_assert_int_eq(ret, 0);
int qqq = s21_eq_matrix(&R, &REZ);
ck_assert_int_eq(qqq, 1);
s21_remove_matrix(&A);
s21_remove_matrix(&R);
s21_remove_matrix(&REZ);

// Тесты на минор матрицы и матрица алгебраических дополнений
#test one_by_one
matrix_t A;
matrix_t result;
s21_create_matrix(1, 1, &A);
A.matrix[0][0] = 4.0;  // Произвольное значение

int code = s21_calc_complements(&A, &result);

ck_assert_int_eq(code, OK);
ck_assert_int_eq(result.rows, 1);
ck_assert_int_eq(result.columns, 1);
ck_assert_double_eq(result.matrix[0][0], 1.0 / 4.0);  // Ожидаемый результат
s21_remove_matrix(&A);
s21_remove_matrix(&result);

#test incorrect
matrix_t m = {0};
matrix_t result = {0};
int code = s21_calc_complements(&m, &result);
ck_assert_int_eq(code, INCORRECT_MATRIX);

#test not_sqare
matrix_t m = {0};
matrix_t result = {0};
int codec = s21_create_matrix(3, 4, &m);
if (codec == OK) {
  int code = s21_calc_complements(&m, &result);
  ck_assert_int_eq(code, CALC_ERROR);
  s21_remove_matrix(&m);
}

#test normal
matrix_t expected, m, result;
int code1 = s21_create_matrix(3, 3, &m);
int code2 = s21_create_matrix(3, 3, &expected);
if (code1 == 0 && code2 == 0) {
  m.matrix[0][0] = 1;
  m.matrix[0][1] = 2;
  m.matrix[0][2] = 3;

  m.matrix[1][0] = 0;
  m.matrix[1][1] = 4;
  m.matrix[1][2] = 2;

  m.matrix[2][0] = 5;
  m.matrix[2][1] = 2;
  m.matrix[2][2] = 1;

  expected.matrix[0][0] = 0;
  expected.matrix[0][1] = 10;
  expected.matrix[0][2] = -20;

  expected.matrix[1][0] = 4;
  expected.matrix[1][1] = -14;
  expected.matrix[1][2] = 8;

  expected.matrix[2][0] = -8;
  expected.matrix[2][1] = -2;
  expected.matrix[2][2] = 4;

  int code = s21_calc_complements(&m, &result);

  ck_assert_int_eq(s21_eq_matrix(&result, &expected), SUCCESS);
  ck_assert_int_eq(code, OK);
  s21_remove_matrix(&m);
  s21_remove_matrix(&result);
  s21_remove_matrix(&expected);
}

#test calc_complements
matrix_t A, R, new_mat;
s21_create_matrix(3, 3, &A);
s21_create_matrix(3, 3, &R);
A.matrix[0][0] = 25.91697506083412;
A.matrix[0][1] = 36.91059796583082;
A.matrix[0][2] = -74.51476406527999;
A.matrix[1][0] = 74.31657215486891;
A.matrix[1][1] = -90.45570022797631;
A.matrix[1][2] = 27.273735358710894;
A.matrix[2][0] = 63.201868292687436;
A.matrix[2][1] = 16.634280168535952;
A.matrix[2][2] = 90.73538931348031;
// expected result
R.matrix[0][0] = -8661.21213100821;
R.matrix[0][1] = -5019.392076924527;
R.matrix[0][2] = 6953.171934520688;
R.matrix[1][0] = -4588.59693837724;
R.matrix[1][1] = 7061.059126287055;
R.matrix[1][2] = 1901.7085269579036;
R.matrix[2][0] = -5733.595279995511;
R.matrix[2][1] = -6244.5345593679185;
R.matrix[2][2] = -5087.407243925776;
int res = s21_calc_complements(&A, &new_mat);
ck_assert_int_eq(res, 0);
int ret = s21_eq_matrix(&R, &new_mat);
ck_assert_int_eq(ret, 1);
s21_remove_matrix(&A);
s21_remove_matrix(&R);
s21_remove_matrix(&new_mat);

// Тесты на определитель матрицы
#test determinant1
int size = 5;
matrix_t m = {0};
s21_create_matrix(size, size, &m);

for (int i = 0; i < size; i++)
  for (int j = 0; j < size; j++) m.matrix[i][j] = j;
double res = 0;
int code = s21_determinant(&m, &res);
ck_assert_double_eq_tol(res, 0, 1e-6);
ck_assert_int_eq(code, OK);

s21_remove_matrix(&m);

#test determinant2
int size = 4;
matrix_t m = {0};
s21_create_matrix(size, size, &m);

for (int i = 0; i < size; i++)
  for (int j = 0; j < size; j++) m.matrix[i][j] = j + i;

double res = 0;
int code = s21_determinant(&m, &res);
ck_assert_double_eq_tol(res, 0, 1e-6);
ck_assert_int_eq(code, OK);

s21_remove_matrix(&m);

#test determinant3
int size = 5;
matrix_t m = {0};
s21_create_matrix(size, size, &m);
m.matrix[0][1] = 6;
m.matrix[0][2] = -2;
m.matrix[0][3] = -1;
m.matrix[0][4] = 5;
m.matrix[1][3] = -9;
m.matrix[1][4] = -7;
m.matrix[2][1] = 15;
m.matrix[2][2] = 35;
m.matrix[3][1] = -1;
m.matrix[3][2] = -11;
m.matrix[3][3] = -2;
m.matrix[3][4] = 1;
m.matrix[4][0] = -2;
m.matrix[4][1] = -2;
m.matrix[4][2] = 3;
m.matrix[4][4] = -2;

double res = 0;
int code = s21_determinant(&m, &res);
ck_assert_double_eq_tol(res, 2480, 1e-6);
ck_assert_int_eq(code, OK);

s21_remove_matrix(&m);

#test determinant4
int size = 3;
matrix_t m = {0};
s21_create_matrix(size, size, &m);
m.matrix[0][0] = 2;
m.matrix[0][1] = 3;
m.matrix[0][2] = 1;
m.matrix[1][0] = 7;
m.matrix[1][1] = 4;
m.matrix[1][2] = 1;
m.matrix[2][0] = 9;
m.matrix[2][1] = -2;
m.matrix[2][2] = 1;

double res = 0;
int code = s21_determinant(&m, &res);
ck_assert_double_eq_tol(res, -32, 1e-6);
ck_assert_int_eq(code, OK);

s21_remove_matrix(&m);

#test determinant5
int size = 2;
matrix_t m = {0};
s21_create_matrix(size, size, &m);
m.matrix[0][0] = -5;
m.matrix[0][1] = -4;
m.matrix[1][0] = -2;
m.matrix[1][1] = -3;

double res = 0;
int code = s21_determinant(&m, &res);
ck_assert_double_eq_tol(res, 7, 1e-6);
ck_assert_int_eq(code, OK);

s21_remove_matrix(&m);

#test determinant6
int size = 1;
matrix_t m = {0};
s21_create_matrix(size, size, &m);
m.matrix[0][0] = -5;

double res = 0;
int code = s21_determinant(&m, &res);
ck_assert_double_eq_tol(res, -5, 1e-6);
ck_assert_int_eq(code, OK);

s21_remove_matrix(&m);

#test determinant7
matrix_t m = {0};
int rows = rand() % 100 + 1;
rows = -rows;
s21_create_matrix(rows, rows, &m);
double res = 0;
int code = s21_determinant(&m, &res);
ck_assert_int_eq(code, INCORRECT_MATRIX);

s21_remove_matrix(&m);

#test determinant8
matrix_t m = {0};
int rows = 4;
int cols = 5;
s21_create_matrix(rows, cols, &m);

for (int i = 0; i < rows; i++) {
  for (int j = 0; j < cols; j++) {
    m.matrix[i][j] = get_rand(DBL_MIN, DBL_MAX) + 1;
  }
}
double res = 0;
int code = s21_determinant(&m, &res);
ck_assert_int_eq(code, CALC_ERROR);

s21_remove_matrix(&m);

#test determinant9
matrix_t A;
double r = 0.0;
s21_create_matrix(3, 3, &A);
A.matrix[0][0] = 12.846474957868395;
A.matrix[0][1] = -38.60197731882359;
A.matrix[0][2] = 97.84236974240218;
A.matrix[1][0] = -80.64046008920906;
A.matrix[1][1] = 94.38869328233113;
A.matrix[1][2] = -56.547599254317866;
A.matrix[2][0] = -32.39695675714806;
A.matrix[2][1] = 41.77062384890857;
A.matrix[2][2] = -30.60493963201266;
int res = s21_determinant(&A, &r);
ck_assert_int_eq(res, 0);
ck_assert(fabs(r - (-12594.429857733581)) < 1e-9);
s21_remove_matrix(&A);

// Тесты на обратную матрицу
#test inverse_1
matrix_t A, C;
s21_create_matrix(3, 3, &A);
s21_create_matrix(3, 3, &C);
C.matrix[0][0] = 1.0;
C.matrix[0][1] = -1.0;
C.matrix[0][2] = 1.0;
C.matrix[1][0] = -38.0;
C.matrix[1][1] = 41.0;
C.matrix[1][2] = -34.0;
C.matrix[2][0] = 27.0;
C.matrix[2][1] = -29.0;
C.matrix[2][2] = 24.0;
A.matrix[0][0] = 2.0;
A.matrix[0][1] = 5.0;
A.matrix[0][2] = 7.0;
A.matrix[1][0] = 6.0;
A.matrix[1][1] = 3.0;
A.matrix[1][2] = 4.0;
A.matrix[2][0] = 5.0;
A.matrix[2][1] = -2.0;
A.matrix[2][2] = -3.0;
matrix_t B;
s21_inverse_matrix(&A, &B);
int res = s21_eq_matrix(&B, &C);
ck_assert_int_eq(res, 1);
s21_remove_matrix(&A);
s21_remove_matrix(&B);
s21_remove_matrix(&C);

#test one_by_one_invert
matrix_t m;
if (s21_create_matrix(1, 1, &m) == OK) {
  matrix_t result;
  m.matrix[0][0] = 4.0;  // Определенное значение

  int code1 = s21_calc_complements(&m, &result);
  ck_assert_int_eq(code1, OK);

  // Проверка, что результат обратного элемента близок к ожидаемому (с
  // погрешностью 1e-6)
  double expected_inverse = 1.0 / 4.0;
  ck_assert(fabs(result.matrix[0][0] - expected_inverse) < 1e-6);

  s21_remove_matrix(&m);
  s21_remove_matrix(&result);
}

#test zero_det
matrix_t m, result;
int codec = s21_create_matrix(1, 1, &m);
if (codec == 0) {
  int code = s21_inverse_matrix(&m, &result);
  ck_assert_int_eq(code, CALC_ERROR);
  s21_remove_matrix(&m);
}

#test incorrect_invert
matrix_t m, result;
int code = s21_inverse_matrix(&m, &result);
ck_assert_int_eq(code, INCORRECT_MATRIX);

#test determinant_0
int size = 2;
matrix_t m;
s21_create_matrix(size, size, &m);
m.matrix[0][0] = 1;
m.matrix[0][1] = 1;
m.matrix[1][0] = 1;
m.matrix[1][1] = 1;

matrix_t result = {0};
int code = s21_inverse_matrix(&m, &result);
ck_assert_int_eq(code, CALC_ERROR);

s21_remove_matrix(&m);

#test not_sqare_invert
matrix_t m = {0};
matrix_t result = {0};
int codec = s21_create_matrix(1, 4, &m);
if (codec == 0) {
  int code = s21_inverse_matrix(&m, &result);
  ck_assert_int_eq(code, CALC_ERROR);
  s21_remove_matrix(&m);
}

#test normal_invert
matrix_t m = {0};
matrix_t expected = {0};
int codec1, codec2;
codec1 = s21_create_matrix(3, 3, &m);
if (codec1 == 0) codec2 = s21_create_matrix(3, 3, &expected);

if (codec2 == 0) {
  m.matrix[0][0] = 2;
  m.matrix[0][1] = 5;
  m.matrix[0][2] = 7;

  m.matrix[1][0] = 6;
  m.matrix[1][1] = 3;
  m.matrix[1][2] = 4;

  m.matrix[2][0] = 5;
  m.matrix[2][1] = -2;
  m.matrix[2][2] = -3;

  expected.matrix[0][0] = 1;
  expected.matrix[0][1] = -1;
  expected.matrix[0][2] = 1;

  expected.matrix[1][0] = -38;
  expected.matrix[1][1] = 41;
  expected.matrix[1][2] = -34;

  expected.matrix[2][0] = 27;
  expected.matrix[2][1] = -29;
  expected.matrix[2][2] = 24;
  matrix_t result = {0};
  int code = s21_inverse_matrix(&m, &result);

  ck_assert_int_eq(s21_eq_matrix(&result, &expected), SUCCESS);
  ck_assert_int_eq(code, OK);

  s21_remove_matrix(&m);
  s21_remove_matrix(&result);
  s21_remove_matrix(&expected);
}

#test inverse
/* int size = rand() % 100 + 1; */
int size = 3;
matrix_t m = {0};
s21_create_matrix(size, size, &m);

m.matrix[0][0] = 2;
m.matrix[0][1] = 5;
m.matrix[0][2] = 7;
m.matrix[1][0] = 6;
m.matrix[1][1] = 3;
m.matrix[1][2] = 4;
m.matrix[2][0] = 5;
m.matrix[2][1] = -2;
m.matrix[2][2] = -3;

matrix_t res = {0};
s21_inverse_matrix(&m, &res);

matrix_t expected = {0};
s21_create_matrix(size, size, &expected);
expected.matrix[0][0] = 1;
expected.matrix[0][1] = -1;
expected.matrix[0][2] = 1;
expected.matrix[1][0] = -38;
expected.matrix[1][1] = 41;
expected.matrix[1][2] = -34;
expected.matrix[2][0] = 27;
expected.matrix[2][1] = -29;
expected.matrix[2][2] = 24;

ck_assert_int_eq(s21_eq_matrix(&expected, &res), SUCCESS);

s21_remove_matrix(&expected);
s21_remove_matrix(&res);
s21_remove_matrix(&m);
